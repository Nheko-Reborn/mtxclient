#pragma once

#if __has_include(<nlohmann/json_fwd.hpp>)
#include <nlohmann/json_fwd.hpp>
#else
#include <nlohmann/json.hpp>
#endif

#include "mtx/events/event_type.hpp"
#include "mtx/events/messages/image.hpp"
#include "mtx/events/redaction.hpp"
#include "mtx/identifiers.hpp"

using json = nlohmann::json;
namespace mtx {
namespace events {
//! The basic set of fields all events must have.
template<class Content>
struct Event
{
        //! The fields in this object will vary depending on the type of event.
        //! When interacting with the REST API, this is the HTTP body.
        Content content;
        //! The type of event.
        //! This *should* be namespaced similar to Java package
        //! naming conventions e.g. 'com.example.subdomain.event.type'
        EventType type;
        //! Contains the fully-qualified ID of the user who sent this event.
        std::string sender;
};

template<class Content>
void
to_json(json &obj, const Event<Content> &event);

template<class Content>
void
from_json(const json &obj, Event<Content> &event);

//! Extension of the Event type for device events.
template<class Content>
struct DeviceEvent : public Event<Content>
{
        std::string sender;
};

template<class Content>
void
from_json(const json &obj, DeviceEvent<Content> &event);

template<class Content>
void
to_json(json &obj, const DeviceEvent<Content> &event);

struct UnsignedData
{
        //! The time in milliseconds that has elapsed since the event was sent.
        //! This field is generated by the local homeserver,
        //! and may be incorrect if the local time on at least one
        //! of the two servers is out of sync, which can cause the age to
        //! either be negative or greater than it actually is.
        uint64_t age = 0;
        //! The client-supplied transaction ID, if the client
        //! being given the event is the same one which sent it.
        std::string transaction_id;
        std::string prev_sender;
        std::string replaces_state;
        //! The event ID that redacted this event.
        std::string redacted_by;
        //! The event that redacted this event.
        std::optional<Event<mtx::events::msg::Redaction>> redacted_because;
};

void
from_json(const json &obj, UnsignedData &data);

void
to_json(json &obj, const UnsignedData &event);

template<class Content>
struct StrippedEvent : public Event<Content>
{
        std::string state_key;
};

template<class Content>
void
from_json(const json &obj, StrippedEvent<Content> &event);

template<class Content>
void
to_json(json &obj, const StrippedEvent<Content> &event);

//! RoomEvent.
template<class Content>
struct RoomEvent : public Event<Content>
{
        //! The globally unique event identifier.
        std::string event_id;
        //! The ID of the room associated with this event.
        std::string room_id;
        //! Timestamp in milliseconds on originating homeserver
        //! when this event was sent.
        uint64_t origin_server_ts;
        // SPEC_BUG: The contents of unsigned_data are also present as top level keys.
        //! Contains optional extra information about the event.
        UnsignedData unsigned_data;
};

template<class Content>
void
from_json(const json &obj, RoomEvent<Content> &event);

template<class Content>
void
to_json(json &obj, const RoomEvent<Content> &event);

//! Extension of the RoomEvent.
template<class Content>
struct StateEvent : public RoomEvent<Content>
{
        //! A unique key which defines the overwriting semantics
        //! for this piece of room state.
        std::string state_key;
};

template<class Content>
void
to_json(json &obj, const StateEvent<Content> &event);

template<class Content>
void
from_json(const json &obj, StateEvent<Content> &event);

//! Extension of the RoomEvent.
template<class Content>
struct RedactionEvent : public RoomEvent<Content>
{
        //! The event id of the event that was redacted.
        std::string redacts;
};

template<class Content>
void
to_json(json &obj, const RedactionEvent<Content> &event);

template<class Content>
void
from_json(const json &obj, RedactionEvent<Content> &event);

//! Extension of the RoomEvent.
template<class Content>
struct EncryptedEvent : public RoomEvent<Content>
{};

template<class Content>
void
to_json(json &obj, const EncryptedEvent<Content> &event);

template<class Content>
void
from_json(const json &obj, EncryptedEvent<Content> &event);

enum class MessageType
{
        // m.audio
        Audio,
        // m.emote
        Emote,
        // m.file
        File,
        // m.image
        Image,
        // m.location
        Location,
        // m.notice
        Notice,
        // m.text
        Text,
        // m.video
        Video,
        /// m.key.verification.request
        KeyVerificationRequest,
        // Unrecognized message type
        Unknown,
};

MessageType
getMessageType(const std::string &type);

MessageType
getMessageType(const json &obj);

struct Sticker : public RoomEvent<mtx::events::msg::StickerImage>
{};

} // namespace events
} // namespace mtx
